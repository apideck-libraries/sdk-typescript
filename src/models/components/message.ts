/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Currency, Currency$inboundSchema } from "./currency.js";
import {
  PassThroughBody,
  PassThroughBody$inboundSchema,
  PassThroughBody$Outbound,
  PassThroughBody$outboundSchema,
} from "./passthroughbody.js";

/**
 * Set to sms for SMS messages and mms for MMS messages.
 */
export const MessageType = {
  Sms: "sms",
  Mms: "mms",
} as const;
/**
 * Set to sms for SMS messages and mms for MMS messages.
 */
export type MessageType = ClosedEnum<typeof MessageType>;

/**
 * The direction of the message.
 */
export const Direction = {
  Inbound: "inbound",
  OutboundApi: "outbound-api",
  OutboundCall: "outbound-call",
  OutboundReply: "outbound-reply",
  Unknown: "unknown",
} as const;
/**
 * The direction of the message.
 */
export type Direction = ClosedEnum<typeof Direction>;

/**
 * Status of the delivery of the message.
 */
export const MessageStatus = {
  Accepted: "accepted",
  Scheduled: "scheduled",
  Canceled: "canceled",
  Queued: "queued",
  Sending: "sending",
  Sent: "sent",
  Failed: "failed",
  Delivered: "delivered",
  Undelivered: "undelivered",
  Receiving: "receiving",
  Received: "received",
  Read: "read",
} as const;
/**
 * Status of the delivery of the message.
 */
export type MessageStatus = ClosedEnum<typeof MessageStatus>;

/**
 * Price of the message.
 */
export type Price = {
  perUnit?: string | undefined;
  totalAmount?: string | undefined;
  /**
   * Indicates the associated currency for an amount of money. Values correspond to [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217).
   */
  currency?: Currency | null | undefined;
};

/**
 * The error returned if your message status is failed or undelivered.
 */
export type ErrorT = {
  /**
   * The error_code provides more information about the failure. If the message was successful, this value is null
   */
  code?: string | undefined;
  message?: string | undefined;
};

export type Message = {
  /**
   * A unique identifier for an object.
   */
  id?: string | undefined;
  /**
   * The phone number that initiated the message.
   */
  from: string;
  /**
   * The phone number that received the message.
   */
  to: string;
  subject?: string | undefined;
  /**
   * The message text.
   */
  body: string;
  /**
   * Set to sms for SMS messages and mms for MMS messages.
   */
  type?: MessageType | undefined;
  /**
   * The number of units that make up the complete message. Messages can be split up due to the constraints of the message size.
   */
  numberOfUnits?: number | undefined;
  /**
   * The number of media files associated with the message.
   */
  numberOfMediaFiles?: number | undefined;
  /**
   * The direction of the message.
   */
  direction?: Direction | undefined;
  /**
   * Status of the delivery of the message.
   */
  status?: MessageStatus | undefined;
  /**
   * The scheduled date and time of the message.
   */
  scheduledAt?: Date | undefined;
  /**
   * The date and time that the message was sent
   */
  sentAt?: Date | undefined;
  /**
   * Define a webhook to receive delivery notifications.
   */
  webhookUrl?: string | undefined;
  /**
   * A client reference.
   */
  reference?: string | undefined;
  /**
   * Price of the message.
   */
  price?: Price | undefined;
  /**
   * The error returned if your message status is failed or undelivered.
   */
  error?: ErrorT | undefined;
  /**
   * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
   */
  messagingServiceId?: string | undefined;
  /**
   * When custom mappings are configured on the resource, the result is included here.
   */
  customMappings?: { [k: string]: any } | null | undefined;
  /**
   * The user who last updated the object.
   */
  updatedBy?: string | null | undefined;
  /**
   * The user who created the object.
   */
  createdBy?: string | null | undefined;
  /**
   * The date and time when the object was last updated.
   */
  updatedAt?: Date | null | undefined;
  /**
   * The date and time when the object was created.
   */
  createdAt?: Date | null | undefined;
  /**
   * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
   */
  passThrough?: Array<PassThroughBody> | undefined;
};

export type MessageInput = {
  /**
   * The phone number that initiated the message.
   */
  from: string;
  /**
   * The phone number that received the message.
   */
  to: string;
  subject?: string | undefined;
  /**
   * The message text.
   */
  body: string;
  /**
   * Set to sms for SMS messages and mms for MMS messages.
   */
  type?: MessageType | undefined;
  /**
   * The scheduled date and time of the message.
   */
  scheduledAt?: Date | undefined;
  /**
   * Define a webhook to receive delivery notifications.
   */
  webhookUrl?: string | undefined;
  /**
   * A client reference.
   */
  reference?: string | undefined;
  /**
   * The ID of the Messaging Service used with the message. In case of Plivo this links to the Powerpack ID.
   */
  messagingServiceId?: string | undefined;
  /**
   * The pass_through property allows passing service-specific, custom data or structured modifications in request body when creating or updating resources.
   */
  passThrough?: Array<PassThroughBody> | undefined;
};

/** @internal */
export const MessageType$inboundSchema: z.ZodNativeEnum<typeof MessageType> = z
  .nativeEnum(MessageType);
/** @internal */
export const MessageType$outboundSchema: z.ZodNativeEnum<typeof MessageType> =
  MessageType$inboundSchema;

/** @internal */
export const Direction$inboundSchema: z.ZodNativeEnum<typeof Direction> = z
  .nativeEnum(Direction);

/** @internal */
export const MessageStatus$inboundSchema: z.ZodNativeEnum<
  typeof MessageStatus
> = z.nativeEnum(MessageStatus);

/** @internal */
export const Price$inboundSchema: z.ZodType<Price, z.ZodTypeDef, unknown> = z
  .object({
    per_unit: z.string().optional(),
    total_amount: z.string().optional(),
    currency: z.nullable(Currency$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "per_unit": "perUnit",
      "total_amount": "totalAmount",
    });
  });

export function priceFromJSON(
  jsonString: string,
): SafeParseResult<Price, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Price$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Price' from JSON`,
  );
}

/** @internal */
export const ErrorT$inboundSchema: z.ZodType<ErrorT, z.ZodTypeDef, unknown> = z
  .object({
    code: z.string().optional(),
    message: z.string().optional(),
  });

export function errorFromJSON(
  jsonString: string,
): SafeParseResult<ErrorT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ErrorT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorT' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string().optional(),
    from: z.string(),
    to: z.string(),
    subject: z.string().optional(),
    body: z.string(),
    type: MessageType$inboundSchema.optional(),
    number_of_units: z.number().int().optional(),
    number_of_media_files: z.number().int().optional(),
    direction: Direction$inboundSchema.optional(),
    status: MessageStatus$inboundSchema.optional(),
    scheduled_at: z.string().datetime({ offset: true }).transform(v =>
      new Date(v)
    ).optional(),
    sent_at: z.string().datetime({ offset: true }).transform(v => new Date(v))
      .optional(),
    webhook_url: z.string().optional(),
    reference: z.string().optional(),
    price: z.lazy(() => Price$inboundSchema).optional(),
    error: z.lazy(() => ErrorT$inboundSchema).optional(),
    messaging_service_id: z.string().optional(),
    custom_mappings: z.nullable(z.record(z.any())).optional(),
    updated_by: z.nullable(z.string()).optional(),
    created_by: z.nullable(z.string()).optional(),
    updated_at: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    created_at: z.nullable(
      z.string().datetime({ offset: true }).transform(v => new Date(v)),
    ).optional(),
    pass_through: z.array(PassThroughBody$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "number_of_units": "numberOfUnits",
      "number_of_media_files": "numberOfMediaFiles",
      "scheduled_at": "scheduledAt",
      "sent_at": "sentAt",
      "webhook_url": "webhookUrl",
      "messaging_service_id": "messagingServiceId",
      "custom_mappings": "customMappings",
      "updated_by": "updatedBy",
      "created_by": "createdBy",
      "updated_at": "updatedAt",
      "created_at": "createdAt",
      "pass_through": "passThrough",
    });
  });

export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}

/** @internal */
export type MessageInput$Outbound = {
  from: string;
  to: string;
  subject?: string | undefined;
  body: string;
  type?: string | undefined;
  scheduled_at?: string | undefined;
  webhook_url?: string | undefined;
  reference?: string | undefined;
  messaging_service_id?: string | undefined;
  pass_through?: Array<PassThroughBody$Outbound> | undefined;
};

/** @internal */
export const MessageInput$outboundSchema: z.ZodType<
  MessageInput$Outbound,
  z.ZodTypeDef,
  MessageInput
> = z.object({
  from: z.string(),
  to: z.string(),
  subject: z.string().optional(),
  body: z.string(),
  type: MessageType$outboundSchema.optional(),
  scheduledAt: z.date().transform(v => v.toISOString()).optional(),
  webhookUrl: z.string().optional(),
  reference: z.string().optional(),
  messagingServiceId: z.string().optional(),
  passThrough: z.array(PassThroughBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    scheduledAt: "scheduled_at",
    webhookUrl: "webhook_url",
    messagingServiceId: "messaging_service_id",
    passThrough: "pass_through",
  });
});

export function messageInputToJSON(messageInput: MessageInput): string {
  return JSON.stringify(MessageInput$outboundSchema.parse(messageInput));
}
