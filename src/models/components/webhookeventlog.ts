/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  UnifiedApiId,
  UnifiedApiId$inboundSchema,
  UnifiedApiId$outboundSchema,
} from "./unifiedapiid.js";

/**
 * Apideck service provider associated with event.
 */
export type WebhookEventLogService = {
  /**
   * Apideck service provider id.
   */
  id: string;
  /**
   * Apideck service provider name.
   */
  name: string;
};

export type Attempts = {
  /**
   * ISO Date and time when the request was made.
   */
  timestamp?: string | undefined;
  /**
   * Number of attempts webhook endpoint was called before a success was returned or eventually failed
   */
  executionAttempt?: number | undefined;
  /**
   * HTTP Status code that was returned.
   */
  statusCode?: number | undefined;
  /**
   * Whether or not the request was successful.
   */
  success?: boolean | undefined;
};

export type WebhookEventLog = {
  id?: string | undefined;
  /**
   * HTTP Status code that was returned.
   */
  statusCode?: number | undefined;
  /**
   * Whether or not the request was successful.
   */
  success?: boolean | undefined;
  /**
   * ID of your Apideck Application
   */
  applicationId?: string | undefined;
  /**
   * Unique consumer identifier. You can freely choose a consumer ID yourself. Most of the time, this is an ID of your internal data model that represents a user or account in your system (for example account:12345). If the consumer doesn't exist yet, Vault will upsert a consumer based on your ID.
   */
  consumerId?: string | undefined;
  /**
   * Name of Apideck Unified API
   */
  unifiedApi?: UnifiedApiId | undefined;
  /**
   * Apideck service provider associated with event.
   */
  service?: WebhookEventLogService | undefined;
  /**
   * The URL of the webhook endpoint.
   */
  endpoint?: string | undefined;
  /**
   * Name of source event that webhook is subscribed to.
   */
  eventType?: string | undefined;
  /**
   * Number of attempts webhook endpoint was called before a success was returned or eventually failed
   */
  executionAttempt?: number | undefined;
  /**
   * HTTP Method of request to endpoint.
   */
  httpMethod?: string | undefined;
  /**
   * ISO Date and time when the request was made.
   */
  timestamp?: string | undefined;
  /**
   * Name of the Entity described by the attributes delivered within payload
   */
  entityType?: string | undefined;
  /**
   * The JSON stringified payload that was delivered to the webhook endpoint.
   */
  requestBody?: string | undefined;
  /**
   * The JSON stringified response that was returned from the webhook endpoint.
   */
  responseBody?: string | undefined;
  /**
   * If the request has not hit the max retry limit and will be retried.
   */
  retryScheduled?: boolean | undefined;
  /**
   * record of each attempt to call webhook endpoint
   */
  attempts?: Array<Attempts> | undefined;
};

/** @internal */
export const WebhookEventLogService$inboundSchema: z.ZodType<
  WebhookEventLogService,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  name: z.string(),
});

/** @internal */
export type WebhookEventLogService$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const WebhookEventLogService$outboundSchema: z.ZodType<
  WebhookEventLogService$Outbound,
  z.ZodTypeDef,
  WebhookEventLogService
> = z.object({
  id: z.string(),
  name: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WebhookEventLogService$ {
  /** @deprecated use `WebhookEventLogService$inboundSchema` instead. */
  export const inboundSchema = WebhookEventLogService$inboundSchema;
  /** @deprecated use `WebhookEventLogService$outboundSchema` instead. */
  export const outboundSchema = WebhookEventLogService$outboundSchema;
  /** @deprecated use `WebhookEventLogService$Outbound` instead. */
  export type Outbound = WebhookEventLogService$Outbound;
}

export function webhookEventLogServiceToJSON(
  webhookEventLogService: WebhookEventLogService,
): string {
  return JSON.stringify(
    WebhookEventLogService$outboundSchema.parse(webhookEventLogService),
  );
}

export function webhookEventLogServiceFromJSON(
  jsonString: string,
): SafeParseResult<WebhookEventLogService, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebhookEventLogService$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebhookEventLogService' from JSON`,
  );
}

/** @internal */
export const Attempts$inboundSchema: z.ZodType<
  Attempts,
  z.ZodTypeDef,
  unknown
> = z.object({
  timestamp: z.string().optional(),
  execution_attempt: z.number().optional(),
  status_code: z.number().int().optional(),
  success: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "execution_attempt": "executionAttempt",
    "status_code": "statusCode",
  });
});

/** @internal */
export type Attempts$Outbound = {
  timestamp?: string | undefined;
  execution_attempt?: number | undefined;
  status_code?: number | undefined;
  success?: boolean | undefined;
};

/** @internal */
export const Attempts$outboundSchema: z.ZodType<
  Attempts$Outbound,
  z.ZodTypeDef,
  Attempts
> = z.object({
  timestamp: z.string().optional(),
  executionAttempt: z.number().optional(),
  statusCode: z.number().int().optional(),
  success: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    executionAttempt: "execution_attempt",
    statusCode: "status_code",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Attempts$ {
  /** @deprecated use `Attempts$inboundSchema` instead. */
  export const inboundSchema = Attempts$inboundSchema;
  /** @deprecated use `Attempts$outboundSchema` instead. */
  export const outboundSchema = Attempts$outboundSchema;
  /** @deprecated use `Attempts$Outbound` instead. */
  export type Outbound = Attempts$Outbound;
}

export function attemptsToJSON(attempts: Attempts): string {
  return JSON.stringify(Attempts$outboundSchema.parse(attempts));
}

export function attemptsFromJSON(
  jsonString: string,
): SafeParseResult<Attempts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Attempts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Attempts' from JSON`,
  );
}

/** @internal */
export const WebhookEventLog$inboundSchema: z.ZodType<
  WebhookEventLog,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  status_code: z.number().int().optional(),
  success: z.boolean().optional(),
  application_id: z.string().optional(),
  consumer_id: z.string().optional(),
  unified_api: UnifiedApiId$inboundSchema.optional(),
  service: z.lazy(() => WebhookEventLogService$inboundSchema).optional(),
  endpoint: z.string().optional(),
  event_type: z.string().optional(),
  execution_attempt: z.number().optional(),
  http_method: z.string().optional(),
  timestamp: z.string().optional(),
  entity_type: z.string().optional(),
  request_body: z.string().optional(),
  response_body: z.string().optional(),
  retry_scheduled: z.boolean().optional(),
  attempts: z.array(z.lazy(() => Attempts$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "status_code": "statusCode",
    "application_id": "applicationId",
    "consumer_id": "consumerId",
    "unified_api": "unifiedApi",
    "event_type": "eventType",
    "execution_attempt": "executionAttempt",
    "http_method": "httpMethod",
    "entity_type": "entityType",
    "request_body": "requestBody",
    "response_body": "responseBody",
    "retry_scheduled": "retryScheduled",
  });
});

/** @internal */
export type WebhookEventLog$Outbound = {
  id?: string | undefined;
  status_code?: number | undefined;
  success?: boolean | undefined;
  application_id?: string | undefined;
  consumer_id?: string | undefined;
  unified_api?: string | undefined;
  service?: WebhookEventLogService$Outbound | undefined;
  endpoint?: string | undefined;
  event_type?: string | undefined;
  execution_attempt?: number | undefined;
  http_method?: string | undefined;
  timestamp?: string | undefined;
  entity_type?: string | undefined;
  request_body?: string | undefined;
  response_body?: string | undefined;
  retry_scheduled?: boolean | undefined;
  attempts?: Array<Attempts$Outbound> | undefined;
};

/** @internal */
export const WebhookEventLog$outboundSchema: z.ZodType<
  WebhookEventLog$Outbound,
  z.ZodTypeDef,
  WebhookEventLog
> = z.object({
  id: z.string().optional(),
  statusCode: z.number().int().optional(),
  success: z.boolean().optional(),
  applicationId: z.string().optional(),
  consumerId: z.string().optional(),
  unifiedApi: UnifiedApiId$outboundSchema.optional(),
  service: z.lazy(() => WebhookEventLogService$outboundSchema).optional(),
  endpoint: z.string().optional(),
  eventType: z.string().optional(),
  executionAttempt: z.number().optional(),
  httpMethod: z.string().optional(),
  timestamp: z.string().optional(),
  entityType: z.string().optional(),
  requestBody: z.string().optional(),
  responseBody: z.string().optional(),
  retryScheduled: z.boolean().optional(),
  attempts: z.array(z.lazy(() => Attempts$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    statusCode: "status_code",
    applicationId: "application_id",
    consumerId: "consumer_id",
    unifiedApi: "unified_api",
    eventType: "event_type",
    executionAttempt: "execution_attempt",
    httpMethod: "http_method",
    entityType: "entity_type",
    requestBody: "request_body",
    responseBody: "response_body",
    retryScheduled: "retry_scheduled",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace WebhookEventLog$ {
  /** @deprecated use `WebhookEventLog$inboundSchema` instead. */
  export const inboundSchema = WebhookEventLog$inboundSchema;
  /** @deprecated use `WebhookEventLog$outboundSchema` instead. */
  export const outboundSchema = WebhookEventLog$outboundSchema;
  /** @deprecated use `WebhookEventLog$Outbound` instead. */
  export type Outbound = WebhookEventLog$Outbound;
}

export function webhookEventLogToJSON(
  webhookEventLog: WebhookEventLog,
): string {
  return JSON.stringify(WebhookEventLog$outboundSchema.parse(webhookEventLog));
}

export function webhookEventLogFromJSON(
  jsonString: string,
): SafeParseResult<WebhookEventLog, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebhookEventLog$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebhookEventLog' from JSON`,
  );
}
