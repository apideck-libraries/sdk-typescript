/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CreditOrDebit,
  CreditOrDebit$inboundSchema,
  CreditOrDebit$outboundSchema,
} from "./creditordebit.js";

/**
 * The current status of the bank feed statement.
 */
export const StatementStatus = {
  Pending: "pending",
  Rejected: "rejected",
  Success: "success",
} as const;
/**
 * The current status of the bank feed statement.
 */
export type StatementStatus = OpenEnum<typeof StatementStatus>;

/**
 * Type of transaction.
 */
export const BankFeedStatementTransactionType = {
  Credit: "credit",
  Debit: "debit",
  Deposit: "deposit",
  Transfer: "transfer",
  Payment: "payment",
  Other: "other",
} as const;
/**
 * Type of transaction.
 */
export type BankFeedStatementTransactionType = OpenEnum<
  typeof BankFeedStatementTransactionType
>;

export type Transactions = {
  /**
   * The date of the transaction - YYYY:MM::DDThh:mm:ss.sTZD
   */
  postedDate: Date;
  /**
   * A description of the transaction.
   */
  description?: string | undefined;
  /**
   * The amount of the transaction.
   */
  amount: number;
  /**
   * Whether the amount is a credit or debit.
   */
  creditOrDebit: CreditOrDebit;
  /**
   * The ID of the source transaction.
   */
  sourceTransactionId: string;
  /**
   * The counterparty of the transaction.
   */
  counterparty?: string | undefined;
  /**
   * The reference of the transaction.
   */
  reference?: string | undefined;
  /**
   * Type of transaction.
   */
  transactionType?: BankFeedStatementTransactionType | undefined;
};

export type BankFeedStatement = {
  /**
   * A unique identifier for an object.
   */
  id: string;
  /**
   * The ID of the bank feed account this statement belongs to.
   */
  bankFeedAccountId?: string | undefined;
  /**
   * The current status of the bank feed statement.
   */
  status?: StatementStatus | undefined;
  /**
   * Start date of the bank feed statement.
   */
  startDate?: Date | undefined;
  /**
   * End date of the bank feed statement.
   */
  endDate?: Date | undefined;
  /**
   * Balance amount at the start of the period.
   */
  startBalance?: number | undefined;
  /**
   * Whether the amount is a credit or debit.
   */
  startBalanceCreditOrDebit?: CreditOrDebit | undefined;
  /**
   * Balance amount at the end of the period.
   */
  endBalance?: number | undefined;
  /**
   * Whether the amount is a credit or debit.
   */
  endBalanceCreditOrDebit?: CreditOrDebit | undefined;
  /**
   * List of transactions in the bank feed statement.
   */
  transactions?: Array<Transactions> | undefined;
  /**
   * The date and time when the object was created.
   */
  createdAt?: Date | null | undefined;
  /**
   * The user who created the object.
   */
  createdBy?: string | null | undefined;
  /**
   * The date and time when the object was last updated.
   */
  updatedAt?: Date | null | undefined;
  /**
   * The user who last updated the object.
   */
  updatedBy?: string | null | undefined;
};

export type BankFeedStatementInput = {
  /**
   * The ID of the bank feed account this statement belongs to.
   */
  bankFeedAccountId?: string | undefined;
  /**
   * The current status of the bank feed statement.
   */
  status?: StatementStatus | undefined;
  /**
   * Start date of the bank feed statement.
   */
  startDate?: Date | undefined;
  /**
   * End date of the bank feed statement.
   */
  endDate?: Date | undefined;
  /**
   * Balance amount at the start of the period.
   */
  startBalance?: number | undefined;
  /**
   * Whether the amount is a credit or debit.
   */
  startBalanceCreditOrDebit?: CreditOrDebit | undefined;
  /**
   * Balance amount at the end of the period.
   */
  endBalance?: number | undefined;
  /**
   * Whether the amount is a credit or debit.
   */
  endBalanceCreditOrDebit?: CreditOrDebit | undefined;
  /**
   * List of transactions in the bank feed statement.
   */
  transactions?: Array<Transactions> | undefined;
};

/** @internal */
export const StatementStatus$inboundSchema: z.ZodType<
  StatementStatus,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(StatementStatus);
/** @internal */
export const StatementStatus$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  StatementStatus
> = openEnums.outboundSchema(StatementStatus);

/** @internal */
export const BankFeedStatementTransactionType$inboundSchema: z.ZodType<
  BankFeedStatementTransactionType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(BankFeedStatementTransactionType);
/** @internal */
export const BankFeedStatementTransactionType$outboundSchema: z.ZodType<
  string,
  z.ZodTypeDef,
  BankFeedStatementTransactionType
> = openEnums.outboundSchema(BankFeedStatementTransactionType);

/** @internal */
export const Transactions$inboundSchema: z.ZodType<
  Transactions,
  z.ZodTypeDef,
  unknown
> = z.object({
  posted_date: types.date(),
  description: types.optional(types.string()),
  amount: types.number(),
  credit_or_debit: CreditOrDebit$inboundSchema,
  source_transaction_id: types.string(),
  counterparty: types.optional(types.string()),
  reference: types.optional(types.string()),
  transaction_type: types.optional(
    BankFeedStatementTransactionType$inboundSchema,
  ),
}).transform((v) => {
  return remap$(v, {
    "posted_date": "postedDate",
    "credit_or_debit": "creditOrDebit",
    "source_transaction_id": "sourceTransactionId",
    "transaction_type": "transactionType",
  });
});
/** @internal */
export type Transactions$Outbound = {
  posted_date: string;
  description?: string | undefined;
  amount: number;
  credit_or_debit: string;
  source_transaction_id: string;
  counterparty?: string | undefined;
  reference?: string | undefined;
  transaction_type?: string | undefined;
};

/** @internal */
export const Transactions$outboundSchema: z.ZodType<
  Transactions$Outbound,
  z.ZodTypeDef,
  Transactions
> = z.object({
  postedDate: z.date().transform(v => v.toISOString()),
  description: z.string().optional(),
  amount: z.number(),
  creditOrDebit: CreditOrDebit$outboundSchema,
  sourceTransactionId: z.string(),
  counterparty: z.string().optional(),
  reference: z.string().optional(),
  transactionType: BankFeedStatementTransactionType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    postedDate: "posted_date",
    creditOrDebit: "credit_or_debit",
    sourceTransactionId: "source_transaction_id",
    transactionType: "transaction_type",
  });
});

export function transactionsToJSON(transactions: Transactions): string {
  return JSON.stringify(Transactions$outboundSchema.parse(transactions));
}
export function transactionsFromJSON(
  jsonString: string,
): SafeParseResult<Transactions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transactions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transactions' from JSON`,
  );
}

/** @internal */
export const BankFeedStatement$inboundSchema: z.ZodType<
  BankFeedStatement,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  bank_feed_account_id: types.optional(types.string()),
  status: types.optional(StatementStatus$inboundSchema),
  start_date: types.optional(types.date()),
  end_date: types.optional(types.date()),
  start_balance: types.optional(types.number()),
  start_balance_credit_or_debit: types.optional(CreditOrDebit$inboundSchema),
  end_balance: types.optional(types.number()),
  end_balance_credit_or_debit: types.optional(CreditOrDebit$inboundSchema),
  transactions: types.optional(
    z.array(z.lazy(() => Transactions$inboundSchema)),
  ),
  created_at: z.nullable(types.date()).optional(),
  created_by: z.nullable(types.string()).optional(),
  updated_at: z.nullable(types.date()).optional(),
  updated_by: z.nullable(types.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "bank_feed_account_id": "bankFeedAccountId",
    "start_date": "startDate",
    "end_date": "endDate",
    "start_balance": "startBalance",
    "start_balance_credit_or_debit": "startBalanceCreditOrDebit",
    "end_balance": "endBalance",
    "end_balance_credit_or_debit": "endBalanceCreditOrDebit",
    "created_at": "createdAt",
    "created_by": "createdBy",
    "updated_at": "updatedAt",
    "updated_by": "updatedBy",
  });
});

export function bankFeedStatementFromJSON(
  jsonString: string,
): SafeParseResult<BankFeedStatement, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BankFeedStatement$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BankFeedStatement' from JSON`,
  );
}

/** @internal */
export type BankFeedStatementInput$Outbound = {
  bank_feed_account_id?: string | undefined;
  status?: string | undefined;
  start_date?: string | undefined;
  end_date?: string | undefined;
  start_balance?: number | undefined;
  start_balance_credit_or_debit?: string | undefined;
  end_balance?: number | undefined;
  end_balance_credit_or_debit?: string | undefined;
  transactions?: Array<Transactions$Outbound> | undefined;
};

/** @internal */
export const BankFeedStatementInput$outboundSchema: z.ZodType<
  BankFeedStatementInput$Outbound,
  z.ZodTypeDef,
  BankFeedStatementInput
> = z.object({
  bankFeedAccountId: z.string().optional(),
  status: StatementStatus$outboundSchema.optional(),
  startDate: z.date().transform(v => v.toISOString()).optional(),
  endDate: z.date().transform(v => v.toISOString()).optional(),
  startBalance: z.number().optional(),
  startBalanceCreditOrDebit: CreditOrDebit$outboundSchema.optional(),
  endBalance: z.number().optional(),
  endBalanceCreditOrDebit: CreditOrDebit$outboundSchema.optional(),
  transactions: z.array(z.lazy(() => Transactions$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    bankFeedAccountId: "bank_feed_account_id",
    startDate: "start_date",
    endDate: "end_date",
    startBalance: "start_balance",
    startBalanceCreditOrDebit: "start_balance_credit_or_debit",
    endBalance: "end_balance",
    endBalanceCreditOrDebit: "end_balance_credit_or_debit",
  });
});

export function bankFeedStatementInputToJSON(
  bankFeedStatementInput: BankFeedStatementInput,
): string {
  return JSON.stringify(
    BankFeedStatementInput$outboundSchema.parse(bankFeedStatementInput),
  );
}
