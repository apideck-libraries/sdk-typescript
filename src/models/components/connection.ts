/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { AuthType, AuthType$inboundSchema } from "./authtype.js";
import {
  ConnectionState,
  ConnectionState$inboundSchema,
} from "./connectionstate.js";
import { ConsentRecord, ConsentRecord$inboundSchema } from "./consentrecord.js";
import {
  ConsentRecordInput,
  ConsentRecordInput$Outbound,
  ConsentRecordInput$outboundSchema,
} from "./consentrecordinput.js";
import {
  ConsentState,
  ConsentState$inboundSchema,
  ConsentState$outboundSchema,
} from "./consentstate.js";
import { CustomMapping, CustomMapping$inboundSchema } from "./custommapping.js";
import {
  CustomMappingInput,
  CustomMappingInput$Outbound,
  CustomMappingInput$outboundSchema,
} from "./custommappinginput.js";
import { DataScopes, DataScopes$inboundSchema } from "./datascopes.js";
import {
  DataScopesInput,
  DataScopesInput$Outbound,
  DataScopesInput$outboundSchema,
} from "./datascopesinput.js";
import { FormField, FormField$inboundSchema } from "./formfield.js";
import {
  FormFieldOption,
  FormFieldOption$inboundSchema,
  FormFieldOption$Outbound,
  FormFieldOption$outboundSchema,
} from "./formfieldoption.js";
import {
  IntegrationState,
  IntegrationState$inboundSchema,
} from "./integrationstate.js";
import {
  OAuthGrantType,
  OAuthGrantType$inboundSchema,
} from "./oauthgranttype.js";
import {
  WebhookSubscription,
  WebhookSubscription$inboundSchema,
} from "./webhooksubscription.js";

/**
 * Status of the connection.
 */
export const ConnectionStatus = {
  Live: "live",
  Upcoming: "upcoming",
  Requested: "requested",
} as const;
/**
 * Status of the connection.
 */
export type ConnectionStatus = ClosedEnum<typeof ConnectionStatus>;

export const Target = {
  CustomFields: "custom_fields",
  Resource: "resource",
} as const;
export type Target = ClosedEnum<typeof Target>;

export type Value5 = string | number | number;

export type ConnectionValue =
  | string
  | number
  | number
  | boolean
  | Array<string | number | number>;

export type Defaults = {
  target?: Target | undefined;
  id?: string | undefined;
  options?: Array<FormFieldOption> | undefined;
  value?:
    | string
    | number
    | number
    | boolean
    | Array<string | number | number>
    | undefined;
};

export type Configuration = {
  resource?: string | undefined;
  defaults?: Array<Defaults> | undefined;
};

/**
 * Operational health status of the connection
 */
export const Health = {
  Revoked: "revoked",
  MissingSettings: "missing_settings",
  NeedsConsent: "needs_consent",
  NeedsAuth: "needs_auth",
  PendingRefresh: "pending_refresh",
  Ok: "ok",
} as const;
/**
 * Operational health status of the connection
 */
export type Health = ClosedEnum<typeof Health>;

export type Connection = {
  /**
   * The unique identifier of the connection.
   */
  id?: string | undefined;
  /**
   * The ID of the service this connection belongs to.
   */
  serviceId?: string | undefined;
  /**
   * The name of the connection
   */
  name?: string | undefined;
  tagLine?: string | undefined;
  /**
   * The unified API category where the connection belongs to.
   */
  unifiedApi?: string | undefined;
  /**
   * [Connection state flow](#section/Connection-state)
   */
  state?: ConnectionState | undefined;
  /**
   * The current state of the Integration.
   */
  integrationState?: IntegrationState | undefined;
  /**
   * Type of authorization used by the connector
   */
  authType?: AuthType | undefined;
  /**
   * OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
   */
  oauthGrantType?: OAuthGrantType | undefined;
  /**
   * Status of the connection.
   */
  status?: ConnectionStatus | undefined;
  /**
   * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
   */
  enabled?: boolean | undefined;
  /**
   * The website URL of the connection
   */
  website?: string | undefined;
  /**
   * A visual icon of the connection, that will be shown in the Vault
   */
  icon?: string | undefined;
  /**
   * The logo of the connection, that will be shown in the Vault
   */
  logo?: string | undefined;
  /**
   * The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
   */
  authorizeUrl?: string | null | undefined;
  /**
   * The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
   */
  revokeUrl?: string | null | undefined;
  /**
   * Connection settings. Values will persist to `form_fields` with corresponding id
   */
  settings?: { [k: string]: any } | null | undefined;
  /**
   * Attach your own consumer specific metadata
   */
  metadata?: { [k: string]: any } | null | undefined;
  /**
   * The settings that are wanted to create a connection.
   */
  formFields?: Array<FormField> | undefined;
  configuration?: Array<Configuration> | undefined;
  configurableResources?: Array<string> | undefined;
  resourceSchemaSupport?: Array<string> | undefined;
  resourceSettingsSupport?: Array<string> | undefined;
  validationSupport?: boolean | undefined;
  schemaSupport?: boolean | undefined;
  /**
   * List of settings that are required to be configured on integration before authorization can occur
   */
  settingsRequiredForAuthorization?: Array<string> | undefined;
  subscriptions?: Array<WebhookSubscription> | undefined;
  /**
   * Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
   */
  hasGuide?: boolean | undefined;
  /**
   * List of custom mappings configured for this connection
   */
  customMappings?: Array<CustomMapping> | undefined;
  /**
   * The current consent state of the connection
   */
  consentState?: ConsentState | undefined;
  /**
   * Immutable array of consent records for compliance and audit purposes
   */
  consents?: Array<ConsentRecord> | undefined;
  latestConsent?: ConsentRecord | undefined;
  applicationDataScopes?: DataScopes | undefined;
  /**
   * Operational health status of the connection
   */
  health?: Health | undefined;
  /**
   * Unix timestamp in milliseconds when credentials will be deleted if token refresh continues to fail. A value of 0 indicates no active retention window (connection is healthy or not using OAuth token refresh).
   */
  credentialsExpireAt?: number | undefined;
  /**
   * Unix timestamp in milliseconds of the last failed token refresh attempt. A value of 0 indicates no recent failures. This field is used internally to enforce cooldown periods between retry attempts.
   */
  lastRefreshFailedAt?: number | undefined;
  createdAt?: number | undefined;
  updatedAt?: number | null | undefined;
};

export type ConnectionDefaults = {
  id?: string | undefined;
  options?: Array<FormFieldOption> | undefined;
  value?:
    | string
    | number
    | number
    | boolean
    | Array<string | number | number>
    | undefined;
};

export type ConnectionConfiguration = {
  resource?: string | undefined;
  defaults?: Array<ConnectionDefaults> | undefined;
};

export type ConnectionInput = {
  /**
   * Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
   */
  enabled?: boolean | undefined;
  /**
   * Connection settings. Values will persist to `form_fields` with corresponding id
   */
  settings?: { [k: string]: any } | null | undefined;
  /**
   * Attach your own consumer specific metadata
   */
  metadata?: { [k: string]: any } | null | undefined;
  configuration?: Array<ConnectionConfiguration> | undefined;
  /**
   * List of custom mappings configured for this connection
   */
  customMappings?: Array<CustomMappingInput> | undefined;
  /**
   * The current consent state of the connection
   */
  consentState?: ConsentState | undefined;
  latestConsent?: ConsentRecordInput | undefined;
  applicationDataScopes?: DataScopesInput | undefined;
};

/** @internal */
export const ConnectionStatus$inboundSchema: z.ZodNativeEnum<
  typeof ConnectionStatus
> = z.nativeEnum(ConnectionStatus);

/** @internal */
export const Target$inboundSchema: z.ZodNativeEnum<typeof Target> = z
  .nativeEnum(Target);

/** @internal */
export const Value5$inboundSchema: z.ZodType<Value5, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number().int(), z.number()]);
/** @internal */
export type Value5$Outbound = string | number | number;

/** @internal */
export const Value5$outboundSchema: z.ZodType<
  Value5$Outbound,
  z.ZodTypeDef,
  Value5
> = z.union([z.string(), z.number().int(), z.number()]);

export function value5ToJSON(value5: Value5): string {
  return JSON.stringify(Value5$outboundSchema.parse(value5));
}
export function value5FromJSON(
  jsonString: string,
): SafeParseResult<Value5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value5' from JSON`,
  );
}

/** @internal */
export const ConnectionValue$inboundSchema: z.ZodType<
  ConnectionValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.number().int(),
  z.number(),
  z.boolean(),
  z.array(z.union([z.string(), z.number().int(), z.number()])),
]);
/** @internal */
export type ConnectionValue$Outbound =
  | string
  | number
  | number
  | boolean
  | Array<string | number | number>;

/** @internal */
export const ConnectionValue$outboundSchema: z.ZodType<
  ConnectionValue$Outbound,
  z.ZodTypeDef,
  ConnectionValue
> = z.union([
  z.string(),
  z.number().int(),
  z.number(),
  z.boolean(),
  z.array(z.union([z.string(), z.number().int(), z.number()])),
]);

export function connectionValueToJSON(
  connectionValue: ConnectionValue,
): string {
  return JSON.stringify(ConnectionValue$outboundSchema.parse(connectionValue));
}
export function connectionValueFromJSON(
  jsonString: string,
): SafeParseResult<ConnectionValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConnectionValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConnectionValue' from JSON`,
  );
}

/** @internal */
export const Defaults$inboundSchema: z.ZodType<
  Defaults,
  z.ZodTypeDef,
  unknown
> = z.object({
  target: Target$inboundSchema.optional(),
  id: z.string().optional(),
  options: z.array(FormFieldOption$inboundSchema).optional(),
  value: z.union([
    z.string(),
    z.number().int(),
    z.number(),
    z.boolean(),
    z.array(z.union([z.string(), z.number().int(), z.number()])),
  ]).optional(),
});

export function defaultsFromJSON(
  jsonString: string,
): SafeParseResult<Defaults, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Defaults$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Defaults' from JSON`,
  );
}

/** @internal */
export const Configuration$inboundSchema: z.ZodType<
  Configuration,
  z.ZodTypeDef,
  unknown
> = z.object({
  resource: z.string().optional(),
  defaults: z.array(z.lazy(() => Defaults$inboundSchema)).optional(),
});

export function configurationFromJSON(
  jsonString: string,
): SafeParseResult<Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration' from JSON`,
  );
}

/** @internal */
export const Health$inboundSchema: z.ZodNativeEnum<typeof Health> = z
  .nativeEnum(Health);

/** @internal */
export const Connection$inboundSchema: z.ZodType<
  Connection,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  service_id: z.string().optional(),
  name: z.string().optional(),
  tag_line: z.string().optional(),
  unified_api: z.string().optional(),
  state: ConnectionState$inboundSchema.optional(),
  integration_state: IntegrationState$inboundSchema.optional(),
  auth_type: AuthType$inboundSchema.optional(),
  oauth_grant_type: OAuthGrantType$inboundSchema.optional(),
  status: ConnectionStatus$inboundSchema.optional(),
  enabled: z.boolean().optional(),
  website: z.string().optional(),
  icon: z.string().optional(),
  logo: z.string().optional(),
  authorize_url: z.nullable(z.string()).optional(),
  revoke_url: z.nullable(z.string()).optional(),
  settings: z.nullable(z.record(z.any())).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  form_fields: z.array(FormField$inboundSchema).optional(),
  configuration: z.array(z.lazy(() => Configuration$inboundSchema)).optional(),
  configurable_resources: z.array(z.string()).optional(),
  resource_schema_support: z.array(z.string()).optional(),
  resource_settings_support: z.array(z.string()).optional(),
  validation_support: z.boolean().optional(),
  schema_support: z.boolean().optional(),
  settings_required_for_authorization: z.array(z.string()).optional(),
  subscriptions: z.array(WebhookSubscription$inboundSchema).optional(),
  has_guide: z.boolean().optional(),
  custom_mappings: z.array(CustomMapping$inboundSchema).optional(),
  consent_state: ConsentState$inboundSchema.optional(),
  consents: z.array(ConsentRecord$inboundSchema).optional(),
  latest_consent: ConsentRecord$inboundSchema.optional(),
  application_data_scopes: DataScopes$inboundSchema.optional(),
  health: Health$inboundSchema.optional(),
  credentials_expire_at: z.number().optional(),
  last_refresh_failed_at: z.number().optional(),
  created_at: z.number().optional(),
  updated_at: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "service_id": "serviceId",
    "tag_line": "tagLine",
    "unified_api": "unifiedApi",
    "integration_state": "integrationState",
    "auth_type": "authType",
    "oauth_grant_type": "oauthGrantType",
    "authorize_url": "authorizeUrl",
    "revoke_url": "revokeUrl",
    "form_fields": "formFields",
    "configurable_resources": "configurableResources",
    "resource_schema_support": "resourceSchemaSupport",
    "resource_settings_support": "resourceSettingsSupport",
    "validation_support": "validationSupport",
    "schema_support": "schemaSupport",
    "settings_required_for_authorization": "settingsRequiredForAuthorization",
    "has_guide": "hasGuide",
    "custom_mappings": "customMappings",
    "consent_state": "consentState",
    "latest_consent": "latestConsent",
    "application_data_scopes": "applicationDataScopes",
    "credentials_expire_at": "credentialsExpireAt",
    "last_refresh_failed_at": "lastRefreshFailedAt",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
  });
});

export function connectionFromJSON(
  jsonString: string,
): SafeParseResult<Connection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Connection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Connection' from JSON`,
  );
}

/** @internal */
export type ConnectionDefaults$Outbound = {
  id?: string | undefined;
  options?: Array<FormFieldOption$Outbound> | undefined;
  value?:
    | string
    | number
    | number
    | boolean
    | Array<string | number | number>
    | undefined;
};

/** @internal */
export const ConnectionDefaults$outboundSchema: z.ZodType<
  ConnectionDefaults$Outbound,
  z.ZodTypeDef,
  ConnectionDefaults
> = z.object({
  id: z.string().optional(),
  options: z.array(FormFieldOption$outboundSchema).optional(),
  value: z.union([
    z.string(),
    z.number().int(),
    z.number(),
    z.boolean(),
    z.array(z.union([z.string(), z.number().int(), z.number()])),
  ]).optional(),
});

export function connectionDefaultsToJSON(
  connectionDefaults: ConnectionDefaults,
): string {
  return JSON.stringify(
    ConnectionDefaults$outboundSchema.parse(connectionDefaults),
  );
}

/** @internal */
export type ConnectionConfiguration$Outbound = {
  resource?: string | undefined;
  defaults?: Array<ConnectionDefaults$Outbound> | undefined;
};

/** @internal */
export const ConnectionConfiguration$outboundSchema: z.ZodType<
  ConnectionConfiguration$Outbound,
  z.ZodTypeDef,
  ConnectionConfiguration
> = z.object({
  resource: z.string().optional(),
  defaults: z.array(z.lazy(() => ConnectionDefaults$outboundSchema)).optional(),
});

export function connectionConfigurationToJSON(
  connectionConfiguration: ConnectionConfiguration,
): string {
  return JSON.stringify(
    ConnectionConfiguration$outboundSchema.parse(connectionConfiguration),
  );
}

/** @internal */
export type ConnectionInput$Outbound = {
  enabled?: boolean | undefined;
  settings?: { [k: string]: any } | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  configuration?: Array<ConnectionConfiguration$Outbound> | undefined;
  custom_mappings?: Array<CustomMappingInput$Outbound> | undefined;
  consent_state?: string | undefined;
  latest_consent?: ConsentRecordInput$Outbound | undefined;
  application_data_scopes?: DataScopesInput$Outbound | undefined;
};

/** @internal */
export const ConnectionInput$outboundSchema: z.ZodType<
  ConnectionInput$Outbound,
  z.ZodTypeDef,
  ConnectionInput
> = z.object({
  enabled: z.boolean().optional(),
  settings: z.nullable(z.record(z.any())).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  configuration: z.array(z.lazy(() => ConnectionConfiguration$outboundSchema))
    .optional(),
  customMappings: z.array(CustomMappingInput$outboundSchema).optional(),
  consentState: ConsentState$outboundSchema.optional(),
  latestConsent: ConsentRecordInput$outboundSchema.optional(),
  applicationDataScopes: DataScopesInput$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    customMappings: "custom_mappings",
    consentState: "consent_state",
    latestConsent: "latest_consent",
    applicationDataScopes: "application_data_scopes",
  });
});

export function connectionInputToJSON(
  connectionInput: ConnectionInput,
): string {
  return JSON.stringify(ConnectionInput$outboundSchema.parse(connectionInput));
}
