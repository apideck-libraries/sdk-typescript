// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// ConnectorAuthType - Type of authorization used by the connector
type ConnectorAuthType string

const (
	ConnectorAuthTypeOauth2 ConnectorAuthType = "oauth2"
	ConnectorAuthTypeAPIKey ConnectorAuthType = "apiKey"
	ConnectorAuthTypeBasic  ConnectorAuthType = "basic"
	ConnectorAuthTypeCustom ConnectorAuthType = "custom"
	ConnectorAuthTypeNone   ConnectorAuthType = "none"
)

func (e ConnectorAuthType) ToPointer() *ConnectorAuthType {
	return &e
}
func (e *ConnectorAuthType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "oauth2":
		fallthrough
	case "apiKey":
		fallthrough
	case "basic":
		fallthrough
	case "custom":
		fallthrough
	case "none":
		*e = ConnectorAuthType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectorAuthType: %v", v)
	}
}

// ConnectorOauthGrantType - OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
type ConnectorOauthGrantType string

const (
	ConnectorOauthGrantTypeAuthorizationCode ConnectorOauthGrantType = "authorization_code"
	ConnectorOauthGrantTypeClientCredentials ConnectorOauthGrantType = "client_credentials"
	ConnectorOauthGrantTypePassword          ConnectorOauthGrantType = "password"
)

func (e ConnectorOauthGrantType) ToPointer() *ConnectorOauthGrantType {
	return &e
}
func (e *ConnectorOauthGrantType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "authorization_code":
		fallthrough
	case "client_credentials":
		fallthrough
	case "password":
		*e = ConnectorOauthGrantType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectorOauthGrantType: %v", v)
	}
}

// OauthCredentialsSource - Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
type OauthCredentialsSource string

const (
	OauthCredentialsSourceIntegration OauthCredentialsSource = "integration"
	OauthCredentialsSourceConnection  OauthCredentialsSource = "connection"
)

func (e OauthCredentialsSource) ToPointer() *OauthCredentialsSource {
	return &e
}
func (e *OauthCredentialsSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		fallthrough
	case "connection":
		*e = OauthCredentialsSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OauthCredentialsSource: %v", v)
	}
}

type OauthScopes struct {
	// ID of the OAuth scope.
	ID *string `json:"id,omitempty"`
	// Label of the OAuth scope.
	Label *string `json:"label,omitempty"`
	// List of Unified APIs that request this OAuth Scope by default. Application owners can customize the requested scopes.
	DefaultApis []string `json:"default_apis,omitempty"`
}

func (o *OauthScopes) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *OauthScopes) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *OauthScopes) GetDefaultApis() []string {
	if o == nil {
		return nil
	}
	return o.DefaultApis
}

// ConnectorOauthScopes - OAuth scopes required for the connector. Add these scopes to your OAuth app.
type ConnectorOauthScopes struct {
	// ID of the OAuth scope.
	ID *string `json:"id,omitempty"`
	// Label of the OAuth scope.
	Label *string `json:"label,omitempty"`
}

func (o *ConnectorOauthScopes) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ConnectorOauthScopes) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

type UnifiedApis struct {
	// Name of Apideck Unified API
	ID *UnifiedAPIID `json:"id,omitempty"`
	// Name of the API.
	Name *string `json:"name,omitempty"`
	// Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
	AuthOnly    *bool                  `json:"auth_only,omitempty"`
	OauthScopes []ConnectorOauthScopes `json:"oauth_scopes,omitempty"`
	// List of resources that are supported on the connector.
	SupportedResources []LinkedConnectorResource `json:"supported_resources,omitempty"`
	// List of resources that are not supported on the downstream.
	DownstreamUnsupportedResources []string `json:"downstream_unsupported_resources,omitempty"`
	// List of events that are supported on the connector for this Unified API.
	SupportedEvents []ConnectorEvent `json:"supported_events,omitempty"`
}

func (o *UnifiedApis) GetID() *UnifiedAPIID {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *UnifiedApis) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *UnifiedApis) GetAuthOnly() *bool {
	if o == nil {
		return nil
	}
	return o.AuthOnly
}

func (o *UnifiedApis) GetOauthScopes() []ConnectorOauthScopes {
	if o == nil {
		return nil
	}
	return o.OauthScopes
}

func (o *UnifiedApis) GetSupportedResources() []LinkedConnectorResource {
	if o == nil {
		return nil
	}
	return o.SupportedResources
}

func (o *UnifiedApis) GetDownstreamUnsupportedResources() []string {
	if o == nil {
		return nil
	}
	return o.DownstreamUnsupportedResources
}

func (o *UnifiedApis) GetSupportedEvents() []ConnectorEvent {
	if o == nil {
		return nil
	}
	return o.SupportedEvents
}

type TLSSupport struct {
	Type *string `json:"type,omitempty"`
	// Description of the TLS support
	Description *string `json:"description,omitempty"`
}

func (o *TLSSupport) GetType() *string {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *TLSSupport) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

type Connector struct {
	// ID of the connector.
	ID *string `json:"id,omitempty"`
	// Name of the connector.
	Name *string `json:"name,omitempty"`
	// Status of the connector. Connectors with status live or beta are callable.
	Status *ConnectorStatus `json:"status,omitempty"`
	// A description of the object.
	Description *string `json:"description,omitempty"`
	// Link to a small square icon for the connector.
	IconURL *string `json:"icon_url,omitempty"`
	// Link to the full logo for the connector.
	LogoURL *string `json:"logo_url,omitempty"`
	// Link to the connector's website.
	WebsiteURL *string `json:"website_url,omitempty"`
	// Link to the connector's signup page.
	SignupURL *string `json:"signup_url,omitempty"`
	// Link to the connector's partner program signup page.
	PartnerSignupURL *string `json:"partner_signup_url,omitempty"`
	// Set to `true` when the connector offers a free trial. Use `signup_url` to sign up for a free trial
	FreeTrialAvailable *bool `json:"free_trial_available,omitempty"`
	// Type of authorization used by the connector
	AuthType *ConnectorAuthType `json:"auth_type,omitempty"`
	// Indicates whether a connector only supports authentication. In this case the connector is not mapped to a Unified API, but can be used with the Proxy API
	AuthOnly *bool `json:"auth_only,omitempty"`
	// Set to `true` when connector was implemented from downstream docs only and without API access. This state indicates that integration will require Apideck support, and access to downstream API to validate mapping quality.
	BlindMapped *bool `json:"blind_mapped,omitempty"`
	// OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
	OauthGrantType *ConnectorOauthGrantType `json:"oauth_grant_type,omitempty"`
	// Location of the OAuth client credentials. For most connectors the OAuth client credentials are stored on integration and managed by the application owner. For others they are stored on connection and managed by the consumer in Vault.
	OauthCredentialsSource *OauthCredentialsSource `json:"oauth_credentials_source,omitempty"`
	// List of OAuth Scopes available for this connector.
	OauthScopes []OauthScopes `json:"oauth_scopes,omitempty"`
	// Set to `true` when connector allows the definition of custom scopes.
	CustomScopes *bool `json:"custom_scopes,omitempty"`
	// Indicates whether Apideck Sandbox OAuth credentials are available.
	HasSandboxCredentials *bool              `json:"has_sandbox_credentials,omitempty"`
	Settings              []ConnectorSetting `json:"settings,omitempty"`
	// Service provider identifier
	ServiceID *string `json:"service_id,omitempty"`
	// List of Unified APIs that feature this connector.
	UnifiedApis []UnifiedApis `json:"unified_apis,omitempty"`
	// List of resources that are supported on the connector.
	SupportedResources []LinkedConnectorResource `json:"supported_resources,omitempty"`
	// List of resources that have settings that can be configured.
	ConfigurableResources []string `json:"configurable_resources,omitempty"`
	// List of events that are supported on the connector across all Unified APIs.
	SupportedEvents []ConnectorEvent `json:"supported_events,omitempty"`
	// How webhooks are supported for the connector. Sometimes the connector natively supports webhooks, other times Apideck virtualizes them based on polling.
	WebhookSupport *WebhookSupport `json:"webhook_support,omitempty"`
	// When a connector has schema_support, a call can be made to retrieve a json schema that describes a downstream resource.
	SchemaSupport *SchemaSupport `json:"schema_support,omitempty"`
	Docs          []ConnectorDoc `json:"docs,omitempty"`
	TLSSupport    *TLSSupport    `json:"tls_support,omitempty"`
}

func (o *Connector) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Connector) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Connector) GetStatus() *ConnectorStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Connector) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Connector) GetIconURL() *string {
	if o == nil {
		return nil
	}
	return o.IconURL
}

func (o *Connector) GetLogoURL() *string {
	if o == nil {
		return nil
	}
	return o.LogoURL
}

func (o *Connector) GetWebsiteURL() *string {
	if o == nil {
		return nil
	}
	return o.WebsiteURL
}

func (o *Connector) GetSignupURL() *string {
	if o == nil {
		return nil
	}
	return o.SignupURL
}

func (o *Connector) GetPartnerSignupURL() *string {
	if o == nil {
		return nil
	}
	return o.PartnerSignupURL
}

func (o *Connector) GetFreeTrialAvailable() *bool {
	if o == nil {
		return nil
	}
	return o.FreeTrialAvailable
}

func (o *Connector) GetAuthType() *ConnectorAuthType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Connector) GetAuthOnly() *bool {
	if o == nil {
		return nil
	}
	return o.AuthOnly
}

func (o *Connector) GetBlindMapped() *bool {
	if o == nil {
		return nil
	}
	return o.BlindMapped
}

func (o *Connector) GetOauthGrantType() *ConnectorOauthGrantType {
	if o == nil {
		return nil
	}
	return o.OauthGrantType
}

func (o *Connector) GetOauthCredentialsSource() *OauthCredentialsSource {
	if o == nil {
		return nil
	}
	return o.OauthCredentialsSource
}

func (o *Connector) GetOauthScopes() []OauthScopes {
	if o == nil {
		return nil
	}
	return o.OauthScopes
}

func (o *Connector) GetCustomScopes() *bool {
	if o == nil {
		return nil
	}
	return o.CustomScopes
}

func (o *Connector) GetHasSandboxCredentials() *bool {
	if o == nil {
		return nil
	}
	return o.HasSandboxCredentials
}

func (o *Connector) GetSettings() []ConnectorSetting {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *Connector) GetServiceID() *string {
	if o == nil {
		return nil
	}
	return o.ServiceID
}

func (o *Connector) GetUnifiedApis() []UnifiedApis {
	if o == nil {
		return nil
	}
	return o.UnifiedApis
}

func (o *Connector) GetSupportedResources() []LinkedConnectorResource {
	if o == nil {
		return nil
	}
	return o.SupportedResources
}

func (o *Connector) GetConfigurableResources() []string {
	if o == nil {
		return nil
	}
	return o.ConfigurableResources
}

func (o *Connector) GetSupportedEvents() []ConnectorEvent {
	if o == nil {
		return nil
	}
	return o.SupportedEvents
}

func (o *Connector) GetWebhookSupport() *WebhookSupport {
	if o == nil {
		return nil
	}
	return o.WebhookSupport
}

func (o *Connector) GetSchemaSupport() *SchemaSupport {
	if o == nil {
		return nil
	}
	return o.SchemaSupport
}

func (o *Connector) GetDocs() []ConnectorDoc {
	if o == nil {
		return nil
	}
	return o.Docs
}

func (o *Connector) GetTLSSupport() *TLSSupport {
	if o == nil {
		return nil
	}
	return o.TLSSupport
}
