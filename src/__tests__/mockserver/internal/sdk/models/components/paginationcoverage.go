// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
)

// PaginationCoverageMode - How pagination is implemented on this connector. Native mode means Apideck is using the pagination parameters of the connector. With virtual pagination, the connector does not support pagination, but Apideck emulates it.
type PaginationCoverageMode string

const (
	PaginationCoverageModeNative  PaginationCoverageMode = "native"
	PaginationCoverageModeVirtual PaginationCoverageMode = "virtual"
)

func (e PaginationCoverageMode) ToPointer() *PaginationCoverageMode {
	return &e
}
func (e *PaginationCoverageMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "native":
		fallthrough
	case "virtual":
		*e = PaginationCoverageMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PaginationCoverageMode: %v", v)
	}
}

type PaginationCoverage struct {
	// How pagination is implemented on this connector. Native mode means Apideck is using the pagination parameters of the connector. With virtual pagination, the connector does not support pagination, but Apideck emulates it.
	Mode *PaginationCoverageMode `json:"mode,omitempty"`
	// Indicates whether the connector supports paging through results using the cursor parameter.
	PagingSupport *bool `json:"paging_support,omitempty"`
	// Indicates whether the connector supports changing the page size by using the limit parameter.
	LimitSupport *bool `json:"limit_support,omitempty"`
}

func (o *PaginationCoverage) GetMode() *PaginationCoverageMode {
	if o == nil {
		return nil
	}
	return o.Mode
}

func (o *PaginationCoverage) GetPagingSupport() *bool {
	if o == nil {
		return nil
	}
	return o.PagingSupport
}

func (o *PaginationCoverage) GetLimitSupport() *bool {
	if o == nil {
		return nil
	}
	return o.LimitSupport
}
