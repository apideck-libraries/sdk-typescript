// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

// ConnectionStatus - Status of the connection.
type ConnectionStatus string

const (
	ConnectionStatusLive      ConnectionStatus = "live"
	ConnectionStatusUpcoming  ConnectionStatus = "upcoming"
	ConnectionStatusRequested ConnectionStatus = "requested"
)

func (e ConnectionStatus) ToPointer() *ConnectionStatus {
	return &e
}
func (e *ConnectionStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "live":
		fallthrough
	case "upcoming":
		fallthrough
	case "requested":
		*e = ConnectionStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConnectionStatus: %v", v)
	}
}

type Target string

const (
	TargetCustomFields Target = "custom_fields"
	TargetResource     Target = "resource"
)

func (e Target) ToPointer() *Target {
	return &e
}
func (e *Target) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "custom_fields":
		fallthrough
	case "resource":
		*e = Target(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Target: %v", v)
	}
}

type ConnectionValue1Type string

const (
	ConnectionValue1TypeStr     ConnectionValue1Type = "str"
	ConnectionValue1TypeInteger ConnectionValue1Type = "integer"
	ConnectionValue1TypeNumber  ConnectionValue1Type = "number"
)

type ConnectionValue1 struct {
	Str     *string  `queryParam:"inline"`
	Integer *int64   `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`

	Type ConnectionValue1Type
}

func CreateConnectionValue1Str(str string) ConnectionValue1 {
	typ := ConnectionValue1TypeStr

	return ConnectionValue1{
		Str:  &str,
		Type: typ,
	}
}

func CreateConnectionValue1Integer(integer int64) ConnectionValue1 {
	typ := ConnectionValue1TypeInteger

	return ConnectionValue1{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateConnectionValue1Number(number float64) ConnectionValue1 {
	typ := ConnectionValue1TypeNumber

	return ConnectionValue1{
		Number: &number,
		Type:   typ,
	}
}

func (u *ConnectionValue1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ConnectionValue1TypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		u.Integer = &integer
		u.Type = ConnectionValue1TypeInteger
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ConnectionValue1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectionValue1", string(data))
}

func (u ConnectionValue1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type ConnectionValue1: all fields are null")
}

type ConnectionValue2Type string

const (
	ConnectionValue2TypeStr                     ConnectionValue2Type = "str"
	ConnectionValue2TypeInteger                 ConnectionValue2Type = "integer"
	ConnectionValue2TypeNumber                  ConnectionValue2Type = "number"
	ConnectionValue2TypeBoolean                 ConnectionValue2Type = "boolean"
	ConnectionValue2TypeArrayOfConnectionValue1 ConnectionValue2Type = "arrayOfConnectionValue1"
)

type ConnectionValue2 struct {
	Str                     *string            `queryParam:"inline"`
	Integer                 *int64             `queryParam:"inline"`
	Number                  *float64           `queryParam:"inline"`
	Boolean                 *bool              `queryParam:"inline"`
	ArrayOfConnectionValue1 []ConnectionValue1 `queryParam:"inline"`

	Type ConnectionValue2Type
}

func CreateConnectionValue2Str(str string) ConnectionValue2 {
	typ := ConnectionValue2TypeStr

	return ConnectionValue2{
		Str:  &str,
		Type: typ,
	}
}

func CreateConnectionValue2Integer(integer int64) ConnectionValue2 {
	typ := ConnectionValue2TypeInteger

	return ConnectionValue2{
		Integer: &integer,
		Type:    typ,
	}
}

func CreateConnectionValue2Number(number float64) ConnectionValue2 {
	typ := ConnectionValue2TypeNumber

	return ConnectionValue2{
		Number: &number,
		Type:   typ,
	}
}

func CreateConnectionValue2Boolean(boolean bool) ConnectionValue2 {
	typ := ConnectionValue2TypeBoolean

	return ConnectionValue2{
		Boolean: &boolean,
		Type:    typ,
	}
}

func CreateConnectionValue2ArrayOfConnectionValue1(arrayOfConnectionValue1 []ConnectionValue1) ConnectionValue2 {
	typ := ConnectionValue2TypeArrayOfConnectionValue1

	return ConnectionValue2{
		ArrayOfConnectionValue1: arrayOfConnectionValue1,
		Type:                    typ,
	}
}

func (u *ConnectionValue2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ConnectionValue2TypeStr
		return nil
	}

	var integer int64 = int64(0)
	if err := utils.UnmarshalJSON(data, &integer, "", true, nil); err == nil {
		u.Integer = &integer
		u.Type = ConnectionValue2TypeInteger
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ConnectionValue2TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ConnectionValue2TypeBoolean
		return nil
	}

	var arrayOfConnectionValue1 []ConnectionValue1 = []ConnectionValue1{}
	if err := utils.UnmarshalJSON(data, &arrayOfConnectionValue1, "", true, nil); err == nil {
		u.ArrayOfConnectionValue1 = arrayOfConnectionValue1
		u.Type = ConnectionValue2TypeArrayOfConnectionValue1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ConnectionValue2", string(data))
}

func (u ConnectionValue2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Integer != nil {
		return utils.MarshalJSON(u.Integer, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	if u.ArrayOfConnectionValue1 != nil {
		return utils.MarshalJSON(u.ArrayOfConnectionValue1, "", true)
	}

	return nil, errors.New("could not marshal union type ConnectionValue2: all fields are null")
}

type Default struct {
	Target  *Target           `json:"target,omitempty"`
	ID      *string           `json:"id,omitempty"`
	Options []FormFieldOption `json:"options,omitempty"`
	Value   *ConnectionValue2 `json:"value,omitempty"`
}

func (o *Default) GetTarget() *Target {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *Default) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Default) GetOptions() []FormFieldOption {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *Default) GetValue() *ConnectionValue2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type Configuration struct {
	Resource *string   `json:"resource,omitempty"`
	Defaults []Default `json:"defaults,omitempty"`
}

func (o *Configuration) GetResource() *string {
	if o == nil {
		return nil
	}
	return o.Resource
}

func (o *Configuration) GetDefaults() []Default {
	if o == nil {
		return nil
	}
	return o.Defaults
}

// Health - Operational health status of the connection
type Health string

const (
	HealthRevoked         Health = "revoked"
	HealthMissingSettings Health = "missing_settings"
	HealthNeedsConsent    Health = "needs_consent"
	HealthNeedsAuth       Health = "needs_auth"
	HealthPendingRefresh  Health = "pending_refresh"
	HealthOk              Health = "ok"
)

func (e Health) ToPointer() *Health {
	return &e
}
func (e *Health) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "revoked":
		fallthrough
	case "missing_settings":
		fallthrough
	case "needs_consent":
		fallthrough
	case "needs_auth":
		fallthrough
	case "pending_refresh":
		fallthrough
	case "ok":
		*e = Health(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Health: %v", v)
	}
}

type Connection struct {
	// The unique identifier of the connection.
	ID *string `json:"id,omitempty"`
	// The ID of the service this connection belongs to.
	ServiceID *string `json:"service_id,omitempty"`
	// The name of the connection
	Name    *string `json:"name,omitempty"`
	TagLine *string `json:"tag_line,omitempty"`
	// The unified API category where the connection belongs to.
	UnifiedAPI *string `json:"unified_api,omitempty"`
	// [Connection state flow](#section/Connection-state)
	State *ConnectionState `json:"state,omitempty"`
	// The current state of the Integration.
	IntegrationState *IntegrationState `json:"integration_state,omitempty"`
	// Type of authorization used by the connector
	AuthType *AuthType `json:"auth_type,omitempty"`
	// OAuth grant type used by the connector. More info: https://oauth.net/2/grant-types
	OauthGrantType *OAuthGrantType `json:"oauth_grant_type,omitempty"`
	// Status of the connection.
	Status *ConnectionStatus `json:"status,omitempty"`
	// Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
	Enabled *bool `json:"enabled,omitempty"`
	// The website URL of the connection
	Website *string `json:"website,omitempty"`
	// A visual icon of the connection, that will be shown in the Vault
	Icon *string `json:"icon,omitempty"`
	// The logo of the connection, that will be shown in the Vault
	Logo *string `json:"logo,omitempty"`
	// The OAuth redirect URI. Redirect your users to this URI to let them authorize your app in the connector's UI. Before you can use this URI, you must add `redirect_uri` as a query parameter to the `authorize_url`. Be sure to URL encode the `redirect_uri` part. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
	AuthorizeURL *string `json:"authorize_url,omitempty"`
	// The OAuth revoke URI. Redirect your users to this URI to revoke this connection. Before you can use this URI, you must add `redirect_uri` as a query parameter. Your users will be redirected to this `redirect_uri` after they granted access to your app in the connector's UI.
	RevokeURL *string `json:"revoke_url,omitempty"`
	// Connection settings. Values will persist to `form_fields` with corresponding id
	Settings map[string]any `json:"settings,omitempty"`
	// Attach your own consumer specific metadata
	Metadata map[string]any `json:"metadata,omitempty"`
	// The settings that are wanted to create a connection.
	FormFields              []FormField     `json:"form_fields,omitempty"`
	Configuration           []Configuration `json:"configuration,omitempty"`
	ConfigurableResources   []string        `json:"configurable_resources,omitempty"`
	ResourceSchemaSupport   []string        `json:"resource_schema_support,omitempty"`
	ResourceSettingsSupport []string        `json:"resource_settings_support,omitempty"`
	ValidationSupport       *bool           `json:"validation_support,omitempty"`
	SchemaSupport           *bool           `json:"schema_support,omitempty"`
	// List of settings that are required to be configured on integration before authorization can occur
	SettingsRequiredForAuthorization []string              `json:"settings_required_for_authorization,omitempty"`
	Subscriptions                    []WebhookSubscription `json:"subscriptions,omitempty"`
	// Whether the connector has a guide available in the developer docs or not (https://docs.apideck.com/connectors/{service_id}/docs/consumer+connection).
	HasGuide *bool `json:"has_guide,omitempty"`
	// List of custom mappings configured for this connection
	CustomMappings []CustomMapping `json:"custom_mappings,omitempty"`
	// The current consent state of the connection
	ConsentState *ConsentState `json:"consent_state,omitempty"`
	// Immutable array of consent records for compliance and audit purposes
	Consents              []ConsentRecord `json:"consents,omitempty"`
	LatestConsent         *ConsentRecord  `json:"latest_consent,omitempty"`
	ApplicationDataScopes *DataScopes     `json:"application_data_scopes,omitempty"`
	// Operational health status of the connection
	Health *Health `json:"health,omitempty"`
	// Unix timestamp in milliseconds when credentials will be deleted if token refresh continues to fail. A value of 0 indicates no active retention window (connection is healthy or not using OAuth token refresh).
	CredentialsExpireAt *float64 `json:"credentials_expire_at,omitempty"`
	// Unix timestamp in milliseconds of the last failed token refresh attempt. A value of 0 indicates no recent failures. This field is used internally to enforce cooldown periods between retry attempts.
	LastRefreshFailedAt *float64 `json:"last_refresh_failed_at,omitempty"`
	CreatedAt           *float64 `json:"created_at,omitempty"`
	UpdatedAt           *float64 `json:"updated_at,omitempty"`
}

func (o *Connection) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Connection) GetServiceID() *string {
	if o == nil {
		return nil
	}
	return o.ServiceID
}

func (o *Connection) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Connection) GetTagLine() *string {
	if o == nil {
		return nil
	}
	return o.TagLine
}

func (o *Connection) GetUnifiedAPI() *string {
	if o == nil {
		return nil
	}
	return o.UnifiedAPI
}

func (o *Connection) GetState() *ConnectionState {
	if o == nil {
		return nil
	}
	return o.State
}

func (o *Connection) GetIntegrationState() *IntegrationState {
	if o == nil {
		return nil
	}
	return o.IntegrationState
}

func (o *Connection) GetAuthType() *AuthType {
	if o == nil {
		return nil
	}
	return o.AuthType
}

func (o *Connection) GetOauthGrantType() *OAuthGrantType {
	if o == nil {
		return nil
	}
	return o.OauthGrantType
}

func (o *Connection) GetStatus() *ConnectionStatus {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *Connection) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *Connection) GetWebsite() *string {
	if o == nil {
		return nil
	}
	return o.Website
}

func (o *Connection) GetIcon() *string {
	if o == nil {
		return nil
	}
	return o.Icon
}

func (o *Connection) GetLogo() *string {
	if o == nil {
		return nil
	}
	return o.Logo
}

func (o *Connection) GetAuthorizeURL() *string {
	if o == nil {
		return nil
	}
	return o.AuthorizeURL
}

func (o *Connection) GetRevokeURL() *string {
	if o == nil {
		return nil
	}
	return o.RevokeURL
}

func (o *Connection) GetSettings() map[string]any {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *Connection) GetMetadata() map[string]any {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *Connection) GetFormFields() []FormField {
	if o == nil {
		return nil
	}
	return o.FormFields
}

func (o *Connection) GetConfiguration() []Configuration {
	if o == nil {
		return nil
	}
	return o.Configuration
}

func (o *Connection) GetConfigurableResources() []string {
	if o == nil {
		return nil
	}
	return o.ConfigurableResources
}

func (o *Connection) GetResourceSchemaSupport() []string {
	if o == nil {
		return nil
	}
	return o.ResourceSchemaSupport
}

func (o *Connection) GetResourceSettingsSupport() []string {
	if o == nil {
		return nil
	}
	return o.ResourceSettingsSupport
}

func (o *Connection) GetValidationSupport() *bool {
	if o == nil {
		return nil
	}
	return o.ValidationSupport
}

func (o *Connection) GetSchemaSupport() *bool {
	if o == nil {
		return nil
	}
	return o.SchemaSupport
}

func (o *Connection) GetSettingsRequiredForAuthorization() []string {
	if o == nil {
		return nil
	}
	return o.SettingsRequiredForAuthorization
}

func (o *Connection) GetSubscriptions() []WebhookSubscription {
	if o == nil {
		return nil
	}
	return o.Subscriptions
}

func (o *Connection) GetHasGuide() *bool {
	if o == nil {
		return nil
	}
	return o.HasGuide
}

func (o *Connection) GetCustomMappings() []CustomMapping {
	if o == nil {
		return nil
	}
	return o.CustomMappings
}

func (o *Connection) GetConsentState() *ConsentState {
	if o == nil {
		return nil
	}
	return o.ConsentState
}

func (o *Connection) GetConsents() []ConsentRecord {
	if o == nil {
		return nil
	}
	return o.Consents
}

func (o *Connection) GetLatestConsent() *ConsentRecord {
	if o == nil {
		return nil
	}
	return o.LatestConsent
}

func (o *Connection) GetApplicationDataScopes() *DataScopes {
	if o == nil {
		return nil
	}
	return o.ApplicationDataScopes
}

func (o *Connection) GetHealth() *Health {
	if o == nil {
		return nil
	}
	return o.Health
}

func (o *Connection) GetCredentialsExpireAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CredentialsExpireAt
}

func (o *Connection) GetLastRefreshFailedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastRefreshFailedAt
}

func (o *Connection) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *Connection) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

type DefaultInput struct {
	ID      *string           `json:"id,omitempty"`
	Options []FormFieldOption `json:"options,omitempty"`
	Value   *ConnectionValue2 `json:"value,omitempty"`
}

func (o *DefaultInput) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *DefaultInput) GetOptions() []FormFieldOption {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *DefaultInput) GetValue() *ConnectionValue2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type ConfigurationInput struct {
	Resource *string        `json:"resource,omitempty"`
	Defaults []DefaultInput `json:"defaults,omitempty"`
}

func (o *ConfigurationInput) GetResource() *string {
	if o == nil {
		return nil
	}
	return o.Resource
}

func (o *ConfigurationInput) GetDefaults() []DefaultInput {
	if o == nil {
		return nil
	}
	return o.Defaults
}

type ConnectionInput struct {
	// Whether the connection is enabled or not. You can enable or disable a connection using the Update Connection API.
	Enabled *bool `json:"enabled,omitempty"`
	// Connection settings. Values will persist to `form_fields` with corresponding id
	Settings map[string]any `json:"settings,omitempty"`
	// Attach your own consumer specific metadata
	Metadata      map[string]any       `json:"metadata,omitempty"`
	Configuration []ConfigurationInput `json:"configuration,omitempty"`
	// List of custom mappings configured for this connection
	CustomMappings []CustomMappingInput `json:"custom_mappings,omitempty"`
	// The current consent state of the connection
	ConsentState          *ConsentState       `json:"consent_state,omitempty"`
	LatestConsent         *ConsentRecordInput `json:"latest_consent,omitempty"`
	ApplicationDataScopes *DataScopesInput    `json:"application_data_scopes,omitempty"`
}

func (o *ConnectionInput) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *ConnectionInput) GetSettings() map[string]any {
	if o == nil {
		return nil
	}
	return o.Settings
}

func (o *ConnectionInput) GetMetadata() map[string]any {
	if o == nil {
		return nil
	}
	return o.Metadata
}

func (o *ConnectionInput) GetConfiguration() []ConfigurationInput {
	if o == nil {
		return nil
	}
	return o.Configuration
}

func (o *ConnectionInput) GetCustomMappings() []CustomMappingInput {
	if o == nil {
		return nil
	}
	return o.CustomMappings
}

func (o *ConnectionInput) GetConsentState() *ConsentState {
	if o == nil {
		return nil
	}
	return o.ConsentState
}

func (o *ConnectionInput) GetLatestConsent() *ConsentRecordInput {
	if o == nil {
		return nil
	}
	return o.LatestConsent
}

func (o *ConnectionInput) GetApplicationDataScopes() *DataScopesInput {
	if o == nil {
		return nil
	}
	return o.ApplicationDataScopes
}
